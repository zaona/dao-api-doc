
## 属性
其包含的变量或值。每个属性都有一个名字（也称为“键”或“标识符”）和一个值。这些值可以是任何JavaScript数据类型，包括字符串、数字、布尔值、对象、数组、函数等。

属性通常用于存储与对象相关的数据或状态。例如，如果你有一个表示人的对象，你可能会为这个对象定义一些属性，如`name`、`age`、`address`等。

在JavaScript中，你可以使用点符号（`.`）或方括号（`[]`）来访问或修改对象的属性。例如：
```javascript
// 创建一个对象并定义属性
var person = {
    name: 'Alice',
    age: 30,
    address: {
        city: 'New York',
        state: 'NY'
    }
};

// 访问属性
console.log(person.name); // 输出: Alice
console.log(person['age']); // 输出: 30

// 修改属性
person.name = 'Bob';
person['age'] = 31;

// 访问修改后的属性
console.log(person.name); // 输出: Bob
console.log(person['age']); // 输出: 31

// 访问嵌套对象的属性
console.log(person.address.city); // 输出: New York
```

---


## 静态属性
是与类本身相关联的变量，而不是与类的实例相关联的变量。这意味着静态属性是跨所有类的实例共享的，并且可以在没有创建类的实例的情况下通过类名直接访问。

你可以使用`static`关键字来定义静态属性。这些属性被存储在类的构造函数对象上，而不是在类的实例上。

下面是一个示例，展示了如何在JavaScript中定义和使用静态属性：
```javascript
class MyClass {
    static myStaticProperty = 'This is a static property.';

    myInstanceProperty = 'This is an instance property.';

    static logStaticProperty() {
        console.log(MyClass.myStaticProperty);
    }
}

// 访问静态属性
console.log(MyClass.myStaticProperty); // 输出: This is a static property.

// 调用静态方法，它访问静态属性
MyClass.logStaticProperty(); // 输出: This is a static property.

// 创建类的实例
const instance = new MyClass();

// 注意：你不能通过实例来访问静态属性
// console.log(instance.myStaticProperty); // 这将返回undefined
```

---


## 常量
是一种值在初始化后就不能再被修改或重新赋值的变量。虽然JavaScript本身并没有内置的常量关键字（如C++或Java中的`const`），但自从ES6（ECMAScript 2015）开始，JavaScript引入了`const`关键字来声明常量。

使用`const`声明的变量在初始化后就不能被重新赋值。这意味着一旦给常量赋值后，就不能再给它赋一个新的值。如果尝试这样做，JavaScript会抛出一个错误。

下面是一个JavaScript常量的例子：
```javascript
const PI = 3.14159;

// 试图修改常量的值会导致错误
PI = 3.14; // TypeError: Assignment to constant variable.

console.log(PI); // 输出：3.14159
```
需要注意的是，虽然你不能修改`const`声明的变量的引用（即不能让它指向一个新的值），但如果你声明的常量是一个对象（包括数组、函数等），你仍然可以修改这个对象的内部属性或方法。因为`const`确保的是引用（地址）不变，而不是对象本身的值不变。
```javascript
const person = {
  name: 'Alice',
  age: 30
};

// 可以修改对象的属性
person.age = 31;

// 但不能重新赋值给常量变量
person = { name: 'Bob' }; // TypeError: Assignment to constant variable.

console.log(person.name); // 输出：Alice
console.log(person.age);  // 输出：31
```
在这个例子中，我们可以修改`person`对象的`age`属性，但不能将`person`重新指向一个新的对象。

---


## 构造函数
是一种特殊的函数，主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与`new`运算符一起使用在创建对象的语句中。

构造函数具有以下几个特点：

1.  **命名约定**：通常，构造函数的名称以大写字母开头，以区分与其他函数，但这并不是强制性的，只是一个常见的约定。 
2.  **与**`**new**`**一起使用**：当使用`new`运算符调用一个函数时，该函数就成为了一个构造函数，并且会执行以下操作： 
   - 创建一个新的空对象。
   - 将这个空对象的`__proto__`属性链接到构造函数的`prototype`对象上，从而确保新创建的对象能够继承构造函数原型上的属性和方法。
   - 构造函数内部的`this`指向这个新创建的对象。
   - 执行构造函数内部的代码。
   - 如果构造函数返回了一个非原始类型的值（即对象或函数），则`new`表达式的结果就是这个返回的对象；否则，结果就是新创建的对象。
3.  **原型属性**：每个构造函数都有一个`prototype`属性，它是一个指向原型对象的指针。而原型对象则包含了可以由特定类型的所有实例共享的属性和方法。 
```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;

    this.sayHello = function() {
        console.log('Hello, my name is ' + this.name + ' and I am ' + this.age + ' years old.');
    };
}

var john = new Person('John', 30);
john.sayHello(); // 输出: Hello, my name is John and I am 30 years old.
```
在这个例子中，`Person`就是一个构造函数，我们使用`new`运算符和`Person`构造函数创建了一个新的`Person`对象，并初始化了它的`name`和`age`属性。

---


## 方法
是定义在对象上的函数。它们通常用于执行与对象相关的操作或行为。方法通常通过对象的属性来访问，这些属性名就是方法名。

假设我们有一个表示矩形的对象，并希望有一个方法来计算它的面积：
```javascript
var rectangle = {
    width: 10,
    height: 5,
    
    // 这是一个方法
    calculateArea(){
        return this.width * this.height;
    }
};

// 调用方法
var area = rectangle.calculateArea();
console.log(area); // 输出: 50
```
在上面的示例中，`calculateArea`是`rectangle`对象的一个方法。当我们调用`rectangle.calculateArea()`时，它会返回矩形的面积。

### 构造函数中的方法
在JavaScript中，构造函数通常用于创建具有相同初始结构的新对象。你可以在构造函数中定义方法，以便新创建的对象都具有该方法：
```javascript
function Rectangle(width, height) {
    this.width = width;
    this.height = height;

    this.calculateArea = function() {
        return this.width * this.height;
    };
}

// 创建一个新的Rectangle对象
var rect = new Rectangle(10, 5);

// 调用方法
var area = rect.calculateArea();
console.log(area); // 输出: 50
```

---


## 静态方法
是指定义在类上而不是类实例上的方法。静态方法可以直接通过类名来调用，而不需要创建类的实例。

静态方法通常用于执行与类本身相关，而不是与类的特定实例相关的任务。它们通常用于访问或修改类的静态属性（也称为类属性或类变量），或者执行与类相关的其他实用功能。

以下是如何在JavaScript定义和使用静态方法的示例：
```javascript
class MyClass {
    static myStaticMethod() {
        console.log('This is a static method.');
    }

    myInstanceMethod() {
        console.log('This is an instance method.');
    }
}

// 调用静态方法
MyClass.myStaticMethod(); // 输出: This is a static method.

// 尝试通过实例调用静态方法（这是不允许的，但通常不会抛出错误）
// MyClass.prototype.myStaticMethod(); // 这将不会工作，因为静态方法不在原型链上

// 创建类的实例并调用实例方法
const instance = new MyClass();
instance.myInstanceMethod(); // 输出: This is an instance method.

// 尝试通过实例调用静态方法（这是不允许的，但JavaScript不会阻止你这样做，只是不会按预期工作）
// instance.myStaticMethod(); // 这会调用 undefined，因为实例上没有 myStaticMethod 方法
```

---



## 接口
在JavaScript（ES6及更早版本）中，并没有原生的“接口”（Interface）概念，但你可以使用其他方式来模拟接口的行为。接口在面向对象编程中通常用于定义对象的行为契约，即一个类必须实现哪些方法。

### 使用 TypeScript 中的接口
如果你在使用TypeScript（JavaScript的一个超集），那么可以使用内置的interface关键字来定义接口：
```typescript
interface MyInterface {  
    method1(): void;  
    method2(arg: string): boolean;  
    // 可以添加更多方法签名  
}  
  
// 一个实现了 MyInterface 接口的类  
class MyClass implements MyInterface {  
    method1() {  
        // 实现方法1  
    }  
  
    method2(arg: string) {  
        // 实现方法2  
        return true;  
    }  
}  
  
// 尝试创建一个没有实现所有方法的类会导致编译错误  
class AnotherClass implements MyInterface {  
    method1() {  
        // 实现方法1  
    }  
  
    // method2 没有在这里实现，会导致编译错误  
}
```
在上面的例子中，MyClass实现了MyInterface接口，因此它必须提供method1和method2两个方法的实现。如果AnotherClass没有实现所有接口中定义的方法，TypeScript编译器会报错。

---


## 枚举
在JavaScript中，直到ES6（ECMAScript 2015）之前，并没有原生的枚举（Enum）类型，但你可以使用对象或常量来模拟枚举的行为。然而，从ES2015（也称为ES6）开始，尽管JavaScript本身并没有提供枚举的语法，但开发者们通常会使用常量对象或`const`和`Object.freeze()`来模拟枚举。

在JavaScript中，你可以使用对象来模拟枚举的行为：
```javascript
const MyEnum = {
    VALUE1: 'value1',
    VALUE2: 'value2',
    // ... 可以添加更多的值
};

console.log(MyEnum.VALUE1); // 输出: value1
```

---


## 默认值
是在没有指定具体值或参数时，系统或程序自动赋予某个变量或参数的一个预设值。在编程、系统设置、数据库设计等多个领域都有应用。

在编程中，默认值通常用于函数或方法的参数。如果调用函数或方法时没有为某个参数提供值，那么该参数就会使用默认值。这可以简化代码，使调用者不必为所有参数都提供值。

例如，在JavaScript中，你可以这样定义一个带有默认参数的函数：
```javascript
function greet(name = '匿名用户') {
    console.log('你好，' + name + '!');
}
greet(); // 输出：你好，匿名用户！
greet('张三'); // 输出：你好，张三！
```
在这个例子中，`name` 参数有一个默认值 `'匿名用户'`。如果调用 `greet()` 函数时没有提供 `name` 参数的值，那么函数就会使用 `'匿名用户'` 作为 `name` 的值。

除了编程，默认值也常用于系统设置或数据库设计中。例如，在数据库表中，某些字段可能有一个默认值，当插入新记录而没有为该字段提供值时，就会使用默认值。

总的来说，默认值是一种简化操作、减少错误和提高代码可读性的有效手段。

---


## 只读
属性或变量意味着其值可以被读取，但不能被修改。这通常是通过特定的语法或框架来设置的，以确保某些数据或状态在程序运行时保持不变。

---


## 【可选】Partial<T> 
在TypeScript中，`Partial<T>` 是一个泛型工具类型，它接收一个类型 `T` 并构造一个新的类型，这个新类型中的所有属性都是可选的（即每个属性后面都带有 `?` 符号）。

简单来说，`Partial<T>` 使得你可以创建一个 `T` 类型的对象，但是不必为 `T` 类型的所有属性都提供值，使每个属性都是可选的。

举个例子，假设你有以下的 `Person` 类型：
```typescript
type Person = {
  name: string;
  age: number;
  address: string;
};
```
如果你想要创建一个 `Person` 类型的对象，但只提供 `name` 和 `age` 属性，你会收到一个类型错误，因为 `address` 属性是必需的。

但是，如果你使用 `Partial<Person>`，你就可以只提供部分属性，而不会收到类型错误：
```typescript
type PartialPerson = Partial<Person>;
const partialPerson: PartialPerson = {
  name: 'Alice',
  age: 30, // address 属性被省略了，但不会报错
};
```
在上面的代码中，`PartialPerson` 类型的对象可以只包含 `name`、`age` 或 `address` 的一个或多个属性，也可以一个都不包含，而不会有类型错误。这是因为 `Partial<Person>` 构造的新类型中，`name`、`age` 和 `address` 都是可选的。

---


## 【异步】**Promise**<T>
在 TypeScript 中，`Promise<T>` 是一种表示异步操作最终完成（或失败）及其结果值的方式。这里的 `T` 是一个泛型参数，代表 `Promise` 对象在成功解决（resolve）时返回的值的类型。

简单来说，`Promise` 是一个对象，它代表了一个可能还没有完成（异步）的操作，并且该对象提供了三种状态：

1. **Pending（待定）**：初始状态，既不是成功，也不是失败状态。
2. **Fulfilled（已实现）**：意味着操作成功完成。
3. **Rejected（已拒绝）**：意味着操作失败。

一个 `Promise` 对象最终会处于 fulfilled 或 rejected 状态之一，并且这个状态一旦确定就不会再改变。

`Promise<T>` 允许你为这两种结果（fulfilled 或 rejected）指定回调函数（通常称为 `then` 和 `catch`），这样你就可以在异步操作完成时执行某些操作，或者在操作失败时处理错误。

以下是一个简单的 `Promise<T>` 示例：
```typescript
// 创建一个 Promise 对象，该对象在 1 秒后解决（resolve）并返回一个字符串
const myPromise: Promise<string> = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, Promise!');
  }, 1000);
});

// 使用 then 方法来处理 Promise 解决（resolve）的情况
myPromise.then((result: string) => {
  console.log(result); // 输出 "Hello, Promise!"
}).catch((error: any) => {
  // 处理错误（在这个例子中，错误处理是不必要的，因为我们没有调用 reject）
  console.error('An error occurred:', error);
});
```
在这个例子中，我们创建了一个 `Promise` 对象 `myPromise`，该对象在 1 秒后通过调用 `resolve` 函数来解决（resolve），并传递一个字符串 `'Hello, Promise!'` 作为结果。然后，我们使用 `then` 方法来处理这个结果，并在控制台中打印它。我们还提供了一个 `catch` 方法来处理可能出现的错误（尽管在这个例子中我们并没有调用 `reject` 函数）。
