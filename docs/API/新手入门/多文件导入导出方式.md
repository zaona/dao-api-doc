
# 4. 服务端
- 定义：服务端是指在网络环境中提供服务的专用计算机或软件程序。
- 角色：作为服务提供者，负责接收客户端的请求，处理这些请求，并将处理结果返回给客户端。

### 代码规范
服务端脚本使用CommonJS规范。导入和导出模块使用CommonJS语法，客户端脚本 ES6 风格的`import`无法在服务端脚本中使用。

`module.exports` 是 CommonJS 规范中用于导出模块内容的一种方式。当你使用 `module.exports` 时，你可以将对象、函数、类或其他任何类型的值赋给它，然后这些值就可以被其他通过 `require()` 函数导入该模块的JavaScript文件所访问。

这里有一个简单的例子来说明如何使用 `module.exports` 来导出模块内容：

### 导出
```javascript
// 定义一个加法函数
function add(a, b) {
  return a + b;
}

// 定义一个减法函数
function subtract(a, b) {
  return a - b;
}

//定义一个变量
var a = 1;

// 使用 module.exports 导出这两个函数和变量
// 注意：我们通常导出一个对象，该对象包含我们想要导出的所有内容
module.exports = {add,subtract,a};

// 或者，如果你只想导出一个函数或值，可以直接这样做：
module.exports = add; // 这样只会导出 add 函数
```
注意几点：

- `module.exports`实际上是一个对象，它默认是一个空对象`{}`。当你向`module.exports`赋值时，你实际上是在替换这个默认对象。
- 如果你使用`module.exports = someValue;`的形式，那么整个模块就只会导出`someValue`。如果你想要导出多个内容，你需要将它们作为属性添加到`module.exports`对象上，如上面的例子所示。
- 还有一个`exports`对象，它是`module.exports`的一个引用（即`exports === module.exports`在初始时是成立的）。但是，如果你重新给`exports`赋值，它就不会再是`module.exports`的引用了，这会导致你导出的内容不是你期望的。因此，推荐直接使用`module.exports`来避免混淆。

### **导入**
```javascript
// 导入 moduleA 模块
const moduleA = require('./moduleA.js');

// 现在你可以使用 moduleA 对象来调用 add 和 subtract 函数和变量了
console.log(moduleA.add(5, 3)); // 输出: 8
console.log(moduleA.subtract(5, 3)); // 输出: 2
console.log(moduleA.a); // 输出: 1
```



# 5. 客户端

- 定义：客户端是指通过网络与服务端进行交互的计算机或软件程序，通常是用户直接操作的对象。
- 角色：作为服务请求者，负责向服务端发送请求，并接收服务端返回的数据和结果。

### 代码规范
客户端脚本使用ES6模块化规范。导入和导出模块使用ES6语法，服务端脚本 Node.js/CommonJS 风格的`require`无法在客户端脚本中使用。

- export default：每个模块只能有一个`export default`导出。它用于导出单个值（如函数、类、对象等），并且这个值在导入时可以使用任意名称。
- export：每个模块可以有多个命名导出。每个导出都可以有自己的名称，并且在导入时需要使用花括号 {} 并指定相同的名称（或者使用 as 关键字进行别名处理）来接收。

### 导出
```javascript
// 定义一个加法函数
function add(a, b) {
    return a + b;
}

// 定义一个减法函数
function subtract(a, b) {
    return a - b;
}

//定义一个变量
var a = 1;

export {add,subtract,a}

// 或者  
  
class MyClass {  
  // 类定义...  
}  
  
export default MyClass;
```

### 导入
```javascript
// 导入 add 函数和a变量，add函数给它指定一个别名sum  
import {add as sum,a} from './moduleA';  

console.log(sum(2, 3)); // 输出: 5  
console.log(a); // 输出: 5  

// 或者导入 MyClass 类
import './moduleA';  

const instance = new MyClass();  
// 假设 MyClass 有一个方法 doSomething()  
instance.doSomething(); // 调用 MyClass 实例的方法
```



# 6. 扩展
CommonJS和ES6（ECMAScript 2015）在模块化方面存在显著的差异，这些差异主要体现在模块的输出方式、加载机制、静态与动态特性等方面。以下是详细对比和归纳：

### 1. 模块输出方式

- **CommonJS**：
   - 输出的是值的拷贝。一旦模块被加载，其导出的值就被缓存，模块内部的变化不会影响到已经加载的模块。
   - 使用`module.exports`或`exports`来导出模块内容。`module.exports`可以导出单个对象或函数，而`exports`是`module.exports`的引用，通常用于导出多个属性或方法。
   - 导出的是对象（或值的拷贝），该对象在脚本运行完成后才会生成。
- **ES6**：
   - 输出的是值的引用。模块中的变量或函数与导入它们的模块之间保持动态链接，模块内部的变化会反映到导入的模块中。
   - 使用`export`和`import`关键字来导出和导入模块内容。支持默认导出（只能有一个）和命名导出（可以有多个）。
   - 导出的是静态定义，在代码静态解析阶段就会生成接口，而不是在运行时。

### 2. 加载机制

- **CommonJS**：
   - 运行时加载。当模块被`require()`时，Node.js 会查找并加载指定的模块文件，然后执行该文件中的代码，最后返回`module.exports`指向的对象。
   - `require()`是同步加载模块，按照在代码中出现的顺序进行加载。但 Node.js 会缓存已加载的模块，避免重复加载。
- **ES6**：
   - 编译时输出接口。ES6 模块支持静态分析，可以在编译时就确定模块的依赖关系，并提前处理这些依赖。
   - `import`命令是异步加载（尽管在某些环境下可能被模拟为同步加载），它有一个独立的模块依赖的解析阶段。

### 3. 静态与动态特性

- **CommonJS**：
   - 更多地表现为动态特性。因为模块是在运行时加载的，且导出的是值的拷贝，所以模块内部的变化不会影响到已经加载的模块。
- **ES6**：
   - 更多地表现为静态特性。ES6 模块的设计思想是尽量静态化，使得编译时就能确定模块的依赖关系以及输入和输出的变量。这有助于进行静态分析和优化。

### 4. 兼容性与应用场景

- **CommonJS**：
   - 主要用于服务器端，特别是 Node.js 环境。在浏览器端使用时，需要借助工具（如 Browserify）进行转换。
- **ES6**：
   - 是现代 JavaScript 的标准模块化规范，在浏览器和 Node.js 中都得到广泛支持。它提供了更加简洁、灵活的语法，并且在编译阶段进行静态分析，能够提高性能。

### 5. 其他差异

- **this 指向**：
   - 在 CommonJS 模块中，`this`通常指向当前模块对象（但在严格模式下为`undefined`）。
   - 在 ES6 模块中，由于模块不是对象，`this`的值在模块顶层代码中为`undefined`。

综上所述，CommonJS 和 ES6 在模块化方面存在多方面的差异，这些差异主要体现在输出方式、加载机制、静态与动态特性以及应用场景等方面。在选择使用哪种模块化规范时，需要根据项目的具体需求和目标环境进行综合考虑。
